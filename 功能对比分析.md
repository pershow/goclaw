# GoClaw vs OpenClaw 功能对比分析

**生成时间**: 2026-02-13
**对比版本**:
- GoClaw: Go 1.25.5 实现
- OpenClaw: TypeScript/Node.js 实现 (v2026.2.13)

---

## 一、项目概述

### GoClaw (狗爪)
- **语言**: Go 1.25.5
- **架构**: 模块化、事件驱动
- **定位**: 生产级 AI Agent 框架
- **特点**: 高性能、类型安全、编译型语言

### OpenClaw
- **语言**: TypeScript/Node.js 22.12.0+
- **架构**: 基于 pi-mono 的 agent-loop 设计
- **定位**: 多渠道 AI 网关，可扩展消息集成
- **特点**: 灵活、生态丰富、快速迭代

---

## 二、核心功能对比

### 1. 上下文管理 (Context Management)

#### **GoClaw**
**文件**: `agent/context.go`

**核心特性**:
- **三种提示词模式**:
  - `PromptModeFull`: 完整模式（主 agent）
  - `PromptModeMinimal`: 精简模式（子 agent）
  - `PromptModeNone`: 仅基本身份

- **两阶段技能加载**:
  1. **第一阶段**: 注入技能摘要列表，让 agent 选择
  2. **第二阶段**: 注入选中技能的完整内容

- **系统提示词构建**:
  ```go
  BuildSystemPrompt(skills) -> string
  - 核心身份 + 工具列表
  - 工具调用风格指导
  - 安全提示
  - 错误处理指导（容错模式）
  - 自动重试策略
  - 技能系统（两阶段）
  - Bootstrap 文件（IDENTITY.md, AGENTS.md, SOUL.md, USER.md）
  - 记忆上下文（长期记忆 + 今日笔记）
  - 工作区和运行时信息
  ```

- **消息验证**:
  - `validateHistoryMessages()`: 过滤孤立的 tool 消息
  - 确保每个 tool 消息都有对应的 assistant 消息
  - 向后兼容旧格式

**优势**:
- 明确的模式分离（主/子 agent）
- 两阶段技能加载减少 token 消耗
- 强类型保证消息结构正确性

#### **OpenClaw**
**文件**: `src/agents/context.ts`

**核心特性**:
- **模型上下文窗口推断**:
  - 懒加载 pi-coding-agent 模型元数据
  - 从模型 ID 推断上下文窗口大小
  - 支持自定义 models.json 配置

- **上下文窗口保护**:
  - `context-window-guard.ts`: 防止上下文溢出
  - 动态调整消息历史长度

- **压缩机制**:
  - `compaction.ts`: 消息压缩
  - `compaction.tool-result-details.test.ts`: 工具结果细节压缩

**优势**:
- 动态上下文窗口管理
- 自动压缩机制
- 与 pi-mono 深度集成

**差异总结**:
| 特性 | GoClaw | OpenClaw |
|------|--------|----------|
| 提示词模式 | 3种明确模式 | 动态推断 |
| 技能加载 | 两阶段（摘要→完整） | 一次性加载 |
| 上下文保护 | 手动控制 | 自动压缩 |
| 消息验证 | 严格验证 | 灵活处理 |

---

### 2. 记忆系统 (Memory System)

#### **GoClaw**
**文件**: `agent/memory.go`, `memory/store.go`

**双层记忆架构**:

**A. 简单文件记忆** (`agent/memory.go`):
```go
type MemoryStore struct {
    workspace string
}

功能:
- ReadToday() / AppendToday()        // 今日笔记 (memory/YYYY-MM-DD.md)
- ReadLongTerm() / AppendLongTerm()  // 长期记忆 (memory/MEMORY.md)
- GetMemoryContext()                 // 格式化记忆上下文
- ReadBootstrapFile()                // 读取 bootstrap 文件
- EnsureBootstrapFiles()             // 确保 bootstrap 文件存在
```

**B. 向量记忆系统** (`memory/store.go`):
```go
type SQLiteStore struct {
    db          *sql.DB
    provider    EmbeddingProvider
    // 支持 sqlite-vec 扩展
}

核心功能:
1. 向量相似度搜索 (sqlite-vec)
2. 全文搜索 (FTS5)
3. 混合搜索 (向量 + 文本)
4. 元数据跟踪:
   - importance: 重要性评分
   - access_count: 访问次数
   - tags: 标签
   - last_accessed: 最后访问时间

数据库表结构:
- memories: 主表（文本、向量、元数据）
- memory_vec: 向量搜索虚拟表 (vec0)
- memory_fts: 全文搜索虚拟表 (FTS5)
```

**特点**:
- WAL 模式提升并发性能
- 批量操作优化
- 向量维度动态适配
- 访问计数自动更新

#### **OpenClaw**
**文件**: `src/memory/manager.ts`

**高级记忆管理系统**:

```typescript
class MemoryIndexManager implements MemorySearchManager {
    // 多提供商支持
    private provider: EmbeddingProvider;
    private openAi?: OpenAiEmbeddingClient;
    private gemini?: GeminiEmbeddingClient;
    private voyage?: VoyageEmbeddingClient;

    // 批量嵌入支持
    private batch: {
        enabled: boolean;
        wait: boolean;
        concurrency: number;
        pollIntervalMs: number;
        timeoutMs: number;
    };
}
```

**核心功能**:

1. **多源记忆**:
   - `memory`: 工作区 markdown 文件
   - `sessions`: 会话转录文件
   - `daily`: 每日笔记

2. **智能同步**:
   - 文件监听 (chokidar)
   - 增量索引（仅索引变更文件）
   - 会话增量同步（基于字节/消息阈值）
   - 定时同步（可配置间隔）

3. **嵌入缓存**:
   ```typescript
   embedding_cache 表:
   - provider, model, provider_key, hash
   - embedding, dims, updated_at
   - 自动 LRU 淘汰
   ```

4. **批量嵌入 API**:
   - OpenAI Batch API
   - Gemini Batch API
   - Voyage Batch API
   - 失败自动降级到非批量模式

5. **混合搜索**:
   - 向量搜索 (sqlite-vec)
   - 关键词搜索 (FTS5)
   - 加权合并结果
   - BM25 排序

6. **故障转移**:
   - 自动切换到备用嵌入提供商
   - 批量失败计数器
   - 超时重试机制

**特点**:
- 生产级索引管理
- 原子性重建索引（临时数据库 + 原子交换）
- 会话增量同步（避免全量重建）
- 多提供商故障转移

**差异总结**:
| 特性 | GoClaw | OpenClaw |
|------|--------|----------|
| 记忆层次 | 双层（文件+向量） | 单一向量索引 |
| 文件监听 | 无 | chokidar 实时监听 |
| 增量同步 | 基于哈希 | 基于哈希+会话增量 |
| 嵌入缓存 | 基础缓存 | 高级 LRU 缓存 |
| 批量 API | 不支持 | 支持 3 个提供商 |
| 故障转移 | 无 | 自动切换提供商 |
| 索引重建 | 直接重建 | 原子性交换 |

---

### 3. Agent 执行流程 (Agent Orchestration)

#### **GoClaw**
**文件**: `agent/orchestrator.go`

**执行循环设计**:
```go
func (o *Orchestrator) Run(ctx, prompts) ([]AgentMessage, error) {
    // 主循环
    for {
        hasMoreToolCalls := true
        steeringAfterTools := false

        // 内循环: 处理工具调用和 steering 消息
        for hasMoreToolCalls || len(pendingMessages) > 0 {
            // 1. 处理 pending 消息（注入到下一个 assistant 响应前）
            if len(pendingMessages) > 0 {
                for _, msg := range pendingMessages {
                    state.AddMessage(msg)
                }
                pendingMessages = []AgentMessage{}
            }

            // 2. 流式调用 LLM
            assistantMsg := streamAssistantResponse(ctx, state)
            state.AddMessage(assistantMsg)

            // 3. 检查工具调用
            toolCalls := extractToolCalls(assistantMsg)
            hasMoreToolCalls = len(toolCalls) > 0

            if hasMoreToolCalls {
                // 4. 执行工具调用
                results, steering := executeToolCalls(ctx, toolCalls, state)

                // 5. 添加工具结果消息
                for _, result := range results {
                    state.AddMessage(result)
                }

                // 6. 如果有 steering 消息，跳过剩余工具
                if len(steering) > 0 {
                    pendingMessages = steering
                    break
                }
            }

            // 7. 获取 steering 消息（turn 完成后）
            if !steeringAfterTools && len(pendingMessages) == 0 {
                pendingMessages = fetchSteeringMessages()
            }
        }

        // 8. Agent 将停止，检查 follow-up 消息
        followUpMessages := fetchFollowUpMessages()
        if len(followUpMessages) > 0 {
            pendingMessages = append(pendingMessages, followUpMessages...)
            continue  // 继续外循环
        }

        // 9. 没有更多消息，退出
        break
    }

    return state.Messages, nil
}
```

**关键特性**:
- **嵌套循环结构**:
  - 外循环: 处理 follow-up 消息
  - 内循环: 处理工具调用和 steering 消息

- **Steering 消息支持**:
  - 中断当前工具执行
  - 注入新消息到执行流程

- **事件发射**:
  - `EventAgentStart`, `EventAgentEnd`
  - `EventTurnStart`, `EventTurnEnd`
  - `EventMessageStart`, `EventMessageEnd`
  - `EventToolExecutionStart`, `EventToolExecutionUpdate`, `EventToolExecutionEnd`

- **技能加载跟踪**:
  - 检测 `use_skill` 工具调用
  - 自动更新 `state.LoadedSkills`
  - 下一轮注入完整技能内容

#### **OpenClaw**
**文件**: `src/agents/` (基于 pi-mono)

**基于 pi-mono 的 agent-loop**:
- 使用 `@mariozechner/pi-agent-core` (v0.52.10)
- 使用 `@mariozechner/pi-ai` (v0.52.10)
- 使用 `@mariozechner/pi-coding-agent` (v0.52.10)

**核心组件**:
```typescript
// 认证配置管理
auth-profiles.ts:
- 多认证配置支持
- 认证配置冷却机制
- 认证配置故障标记
- OAuth 回退到主 agent
- 认证配置使用统计

// 工具执行
bash-tools.exec.ts:
- PTY 支持
- 后台进程管理
- 审批 ID 支持
- 路径处理

// CLI 运行器
cli-runner.ts:
- 子进程管理
- 流式输出处理
```

**特点**:
- 深度集成 pi-mono 生态
- 丰富的认证管理
- 复杂的工具执行策略

**差异总结**:
| 特性 | GoClaw | OpenClaw |
|------|--------|----------|
| 循环设计 | 自定义嵌套循环 | pi-mono agent-loop |
| Steering 支持 | 内置支持 | 依赖 pi-mono |
| 事件系统 | 自定义事件 | pi-mono 事件 |
| 技能加载 | 两阶段动态加载 | 一次性加载 |
| 认证管理 | 简单配置 | 复杂多配置管理 |

---

### 4. 会话管理 (Session Management)

#### **GoClaw**
**文件**: `session/manager.go`

**会话结构**:
```go
type Session struct {
    Key       string                 // 会话键
    Messages  []Message              // 消息列表
    CreatedAt time.Time              // 创建时间
    UpdatedAt time.Time              // 更新时间
    Metadata  map[string]interface{} // 元数据
    mu        sync.RWMutex           // 读写锁
}

type Message struct {
    Role       string                 // user, assistant, system, tool
    Content    string                 // 消息内容
    Media      []Media                // 媒体文件
    Timestamp  time.Time              // 时间戳
    Metadata   map[string]interface{} // 元数据
    ToolCallID string                 // 工具调用 ID (tool role)
    ToolCalls  []ToolCall             // 工具调用列表 (assistant role)
}
```

**存储格式**: JSONL (JSON Lines)
```
第一行: 元数据 {"_type": "metadata", "created_at": ..., "updated_at": ..., "metadata": {...}}
后续行: 消息 {"role": "user", "content": "...", "timestamp": "...", ...}
```

**核心功能**:
```go
type Manager struct {
    sessions map[string]*Session  // 内存缓存
    mu       sync.RWMutex         // 读写锁
    baseDir  string               // 存储目录
}

方法:
- GetOrCreate(key) -> (*Session, error)  // 获取或创建会话
- Save(session) -> error                 // 原子性保存（临时文件 + 重命名）
- Delete(key) -> error                   // 删除会话
- List() -> ([]string, error)            // 列出所有会话
```

**特点**:
- 内存缓存 + 磁盘持久化
- 原子性写入（临时文件 + rename）
- 安全键处理（特殊字符转义）
- 并发安全（读写锁）

#### **OpenClaw**
**文件**: `src/commands/agent/session.ts`, `src/config/sessions.js`

**会话解析系统**:
```typescript
type SessionResolution = {
    sessionId: string;
    sessionKey?: string;
    sessionEntry?: SessionEntry;
    sessionStore?: Record<string, SessionEntry>;
    storePath: string;
    isNewSession: boolean;
    persistedThinking?: ThinkLevel;
    persistedVerbose?: VerboseLevel;
};

function resolveSession(opts: {
    cfg: OpenClawConfig;
    to?: string;
    sessionId?: string;
    sessionKey?: string;
    agentId?: string;
}): SessionResolution
```

**会话作用域**:
- `per-sender`: 每个发送者一个会话
- `per-channel`: 每个频道一个会话
- `global`: 全局单一会话

**会话重置策略**:
```typescript
resolveSessionResetPolicy({
    sessionCfg,
    resetType,
    resetOverride: channelReset,
})

支持:
- 时间基础重置（TTL）
- 频道特定重置配置
- 会话新鲜度评估
```

**会话存储**:
- `session-store.ts`: 会话存储抽象
- 支持多 agent 会话隔离
- 会话元数据持久化（thinking level, verbose level）

**特点**:
- 灵活的会话作用域
- 复杂的重置策略
- 多 agent 会话隔离
- 会话新鲜度管理

**差异总结**:
| 特性 | GoClaw | OpenClaw |
|------|--------|----------|
| 存储格式 | JSONL | 自定义格式 |
| 会话作用域 | 基于键 | per-sender/channel/global |
| 重置策略 | 手动 | 自动（TTL + 策略） |
| 并发控制 | 读写锁 | 单线程 Node.js |
| 元数据 | 通用 map | 类型化（thinking, verbose） |
| 多 agent | 通过键区分 | 内置支持 |

---

### 5. 子 Agent 系统 (Subagent System)

#### **GoClaw**
**文件**: `agent/subagent_registry.go`, `agent/subagent_announce.go`

**子 Agent 注册表**:
```go
type SubagentRegistry struct {
    runs map[string]*SubagentRun  // 运行记录
    mu   sync.RWMutex              // 读写锁
}

type SubagentRun struct {
    ID              string
    ParentSessionID string
    CreatedAt       time.Time
    CompletedAt     *time.Time
    Outcome         string
    DeliveryContext map[string]any
}

方法:
- Register(run) -> error
- Get(id) -> (*SubagentRun, error)
- Complete(id, outcome) -> error
- List() -> ([]*SubagentRun, error)
- Cleanup(olderThan) -> error
```

**子 Agent 通知器**:
```go
type SubagentAnnouncer struct {
    bus      *bus.MessageBus
    registry *SubagentRegistry
}

功能:
- AnnounceCompletion(runID, outcome) -> error
  // 向父 agent 发送完成通知

- buildSystemPrompt(mode) -> string
  // 为子 agent 生成系统提示词

- enforceToolPolicy(tools) -> []Tool
  // 工具策略强制执行
```

**特点**:
- 简单的注册表机制
- 通过消息总线通知父 agent
- 工具策略控制

#### **OpenClaw**
**文件**: `src/commands/agent/delivery.ts`

**交付上下文系统**:
```typescript
// 子 agent 完成后的结果交付
type DeliveryContext = {
    outcome: string;
    artifacts?: any[];
    metadata?: Record<string, any>;
};

// 与 ACP (Agent Client Protocol) 集成
```

**特点**:
- 与 ACP 深度集成
- 丰富的交付上下文
- 支持 artifacts

**差异总结**:
| 特性 | GoClaw | OpenClaw |
|------|--------|----------|
| 注册机制 | 内置注册表 | ACP 协议 |
| 通知方式 | 消息总线 | ACP 事件 |
| 工具策略 | 内置强制执行 | 依赖 pi-mono |
| 交付格式 | 简单 outcome | 丰富的 artifacts |

---

## 三、架构差异总结

### GoClaw 架构特点

**优势**:
1. **高性能**: 编译型语言，低延迟
2. **类型安全**: 强类型系统，编译时检查
3. **并发优势**: Goroutine 轻量级并发
4. **内存效率**: 更低的内存占用
5. **简洁设计**: 清晰的模块边界

**劣势**:
1. **生态较小**: Go AI 生态不如 Node.js
2. **迭代速度**: 编译型语言开发速度较慢
3. **功能较少**: 缺少一些高级特性（批量嵌入、自动故障转移）

### OpenClaw 架构特点

**优势**:
1. **生态丰富**: Node.js 生态强大
2. **快速迭代**: 动态语言，开发速度快
3. **功能完善**: 生产级特性（批量 API、故障转移、增量同步）
4. **pi-mono 集成**: 深度集成成熟的 agent 框架
5. **灵活性**: 动态配置，易于扩展

**劣势**:
1. **性能开销**: 解释型语言，运行时开销
2. **内存占用**: Node.js 内存占用较高
3. **类型安全**: 虽有 TypeScript，但运行时无保证
4. **复杂度**: 功能丰富导致代码复杂度高

---

## 四、功能完整度对比

| 功能模块 | GoClaw | OpenClaw | 说明 |
|---------|--------|----------|------|
| **上下文管理** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 有自动压缩 |
| **记忆系统** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 功能更完善 |
| **Agent 执行** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 基于成熟框架 |
| **会话管理** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 策略更灵活 |
| **子 Agent** | ⭐⭐⭐ | ⭐⭐⭐⭐ | OpenClaw 与 ACP 集成 |
| **多渠道支持** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 支持更多平台 |
| **工具系统** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | OpenClaw 工具更丰富 |
| **技能系统** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | GoClaw 两阶段加载更优 |
| **性能** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | GoClaw 性能更好 |
| **可维护性** | ⭐⭐⭐⭐ | ⭐⭐⭐ | GoClaw 代码更简洁 |

---

## 五、关键差异点

### 1. 技能加载策略

**GoClaw**: 两阶段加载
- 第一阶段: 只显示技能摘要，让 agent 选择
- 第二阶段: 注入选中技能的完整内容
- **优势**: 节省 token，减少上下文长度

**OpenClaw**: 一次性加载
- 所有技能内容一次性注入
- **优势**: 实现简单，agent 可以看到所有信息

### 2. 记忆索引策略

**GoClaw**: 基础向量搜索
- 简单的 sqlite-vec 集成
- 基于哈希的增量更新
- 无自动同步机制

**OpenClaw**: 生产级索引管理
- 文件监听自动同步
- 会话增量同步（字节/消息阈值）
- 原子性索引重建
- 批量嵌入 API 支持
- 自动故障转移

### 3. 会话管理策略

**GoClaw**: 简单键值存储
- 基于键的会话管理
- JSONL 格式存储
- 手动会话管理

**OpenClaw**: 复杂策略系统
- 多种会话作用域
- 自动重置策略（TTL）
- 会话新鲜度评估
- 多 agent 隔离

### 4. Agent 执行流程

**GoClaw**: 自定义嵌套循环
- 清晰的循环结构
- 内置 steering 支持
- 自定义事件系统

**OpenClaw**: pi-mono 集成
- 成熟的 agent-loop
- 丰富的认证管理
- 复杂的工具执行策略

---

## 六、推荐使用场景

### 选择 GoClaw 的场景:
1. **性能敏感**: 需要低延迟、高吞吐量
2. **资源受限**: 内存、CPU 资源有限
3. **简单部署**: 单一二进制文件部署
4. **类型安全**: 需要编译时类型检查
5. **长期维护**: 代码简洁，易于维护

### 选择 OpenClaw 的场景:
1. **快速迭代**: 需要快速开发和部署
2. **功能丰富**: 需要完善的生产级特性
3. **生态集成**: 需要 Node.js 生态支持
4. **复杂场景**: 多渠道、多 agent、复杂认证
5. **成熟框架**: 依赖 pi-mono 成熟能力

---

## 七、改进建议

### GoClaw 可以借鉴 OpenClaw 的特性:
1. **文件监听**: 实现自动同步机制
2. **批量嵌入**: 支持批量嵌入 API
3. **故障转移**: 自动切换嵌入提供商
4. **会话策略**: 实现 TTL 和自动重置
5. **原子性重建**: 索引重建时使用临时数据库

### OpenClaw 可以借鉴 GoClaw 的特性:
1. **两阶段技能加载**: 减少 token 消耗
2. **简化架构**: 减少依赖，降低复杂度
3. **类型安全**: 加强运行时类型检查
4. **性能优化**: 考虑使用 Rust/Go 重写核心模块

---

## 八、结论

**GoClaw** 和 **OpenClaw** 各有优势，适用于不同场景:

- **GoClaw** 适合追求性能、简洁、类型安全的场景
- **OpenClaw** 适合需要丰富功能、快速迭代、生态集成的场景

两者在核心功能上相似，但在实现细节和设计哲学上有显著差异。选择哪个取决于具体需求和团队技术栈。

---

**文档生成完毕**
